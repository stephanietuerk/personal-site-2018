<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<link href='//fonts.googleapis.com/css?family=Roboto:400,100,300,500,700,900' rel='stylesheet'>
	<link href='//fonts.googleapis.com/css?family=Roboto+Mono:400,100,300,700' rel='stylesheet'>
  	<title>PROJECT TITLE</title> 
  	<style>
  		body {
	  		font-family: "Roboto", Helvetica, sans-serif;
	  	}
	  	.active-mouseover {
	  		stroke: white;
	  		stroke-width: 2px;
	  		opacity: .5;
	  		/*stroke-dasharray: 2, 2;*/
	  		stroke-linecap: butt;
	  	}
	</style>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="//d3js.org/topojson.v1.min.js"></script>
	<script src="https://d3js.org/d3-array.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.min.js" charset="utf-8"></script>
</head>
<body>
<div id = "text0" style=text-align:center>
	This is our title. It's div id is "text0". Someone can write and style this text.
</div>
<div id = "viz1" style=text-align:center></div>
<div id = "text1" style=text-align:center>
	Here is the next text block. Fill out accordingly. I live in the HTML section of the .html file, in div tag "text1".
</div>
<div id = "perCDDemos" style=text-align:center></div>
<div id = "text2" style=text-align:center>
	More text that needs to be written! I'm div id "text2".
</div>
<div id = "perCDChange" style=text-align:center></div>
<div id = "text3" style=text-align:center>
	I CAN HAZ TEXXXXXXXTTTT. And I can haz it in "text3".
</div>
<div id = "flipTheDistrict" style=text-align:center></div>



<script>

	//Visualization "global" variables
		var rColor = "#f4003d",
			dColor = "#2437ff",
			dMapColor = "#394bff",
			oColor = "#f6b500",
			initialColor = "#cccccc";

		d3.queue()
			.defer(d3.tsv, "data/CD_VoteData.tsv")
			.defer(d3.tsv, "data/CT_VoteData.tsv")
			.defer(d3.tsv, "data/CD_DemoData.tsv")
			.defer(d3.tsv, "data/CD_ChangeData.tsv")
			.defer(d3.tsv, "data/CT_DemoChangeData.tsv")
			.await(makeCensusTractViz);

	//Read in Vote Data and create map from that 
		function makeCensusTractViz (error, cdVotes, ctVotes, cdDemos, cdChange, ctDemoChange) {

			//nest CD Vote Data
			var cdVoteData = d3.nest()
				.key(function(d) {return d.CD;}) 
				.entries(cdVotes);

			console.log(cdVoteData);

			//nest CT Vote Data
			var ctVoteData = d3.nest()
				.key(function(d) {return d.GEO_ID;}) 
				.entries(ctVotes);

			console.log(ctVoteData);

			//nest CD Demo Data
			var cdDemoD = d3.nest()
				.key(function(d) {return d.VAR;}) 
				.entries(cdDemos);

			console.log(cdDemoD);

			//nest CD Change Data
			var cdChangeD = d3.nest()
				.key(function(d) {return d.VAR;}) 
				.entries(cdChange);

			console.log(cdChangeD);

			//nest CT DemoChangeData
			var ctDemoChangeD = d3.nest()
				.key(function(d) {return d.GEO_ID;})
				.entries(ctDemoChange);

			console.log(ctDemoChangeD);


			//Make data dictionaries 
			//CD Vote Data
			var dCDVotesHolder = {};
			cdVoteData.forEach(function(cdVoteData) {
				dCDVotesHolder[cdVoteData.key] = +cdVoteData.values[0].DEM_USC;
				});
				
			var rCDVotesHolder = {};
			cdVoteData.forEach(function(cdVoteData) {
				rCDVotesHolder[cdVoteData.key] = +cdVoteData.values[0].REP_USC;
			});

			var oCDVotesHolder = {};
			cdVoteData.forEach(function(cdVoteData) {
				oCDVotesHolder[cdVoteData.key] = +cdVoteData.values[0].OTHERS_USC;
			});

			var dSum = d3.sum(cdVoteData, function(d) {return d.values[0].DEM_USC;});
			var rSum = d3.sum(cdVoteData, function(d) {return d.values[0].REP_USC;});
			var oSum = d3.sum(cdVoteData, function(d) {return d.values[0].OTHERS_USC;});
			var paSum = (dSum + rSum + oSum);

			//CT Vote Data 2016
			//NOTE: POSITIVE MARGIN = REP, NEGATIVE MARGIN = DEM
			var voteMarginByTract = {};
			ctVoteData.forEach(function(ctVoteData) {
				var dVotes = +ctVoteData.values[0].DEM_USC,
					rVotes = +ctVoteData.values[0].REP_USC,
					oVotes = +ctVoteData.values[0].OTHERS_USC;

				var totalVotes = dVotes + rVotes + oVotes;

				if (totalVotes == 0) {
					voteMarginByTract[ctVoteData.key] = "ERROR";
				}

				else {var margin = (rVotes - dVotes)/totalVotes;
					voteMarginByTract[ctVoteData.key] = +margin;
				}
			});

			//CT Vote Change
			var voteChangeByTract = {};
			ctVoteData.forEach(function(ctVoteData) {
				var dVotes = +ctVoteData.values[0].DEM_USC,
					rVotes = +ctVoteData.values[0].REP_USC,
					oVotes = +ctVoteData.values[0].OTHERS_USC;

				var totalVotes = dVotes + rVotes + oVotes;

				var dVotes2012 = +ctVoteData.values[0].DEM_2012,
					rVotes2012 = +ctVoteData.values[0].REP_2012,
					oVotes2012 = +ctVoteData.values[0].OTH_2012;

				var totalVotes2012 = dVotes2012 + rVotes2012 + oVotes2012;

				if (totalVotes2012 == 0) {
					voteChangeByTract[ctVoteData.key] = "ERROR";
				}

				if (totalVotes == 0) {
					voteChangeByTract[ctVoteData.key] = "ERROR";
				}

				else {

					var margin2016 = (rVotes - dVotes)/totalVotes,
						margin2012 = (rVotes2012 - dVotes2012)/totalVotes2012;

					var change = margin2016 - margin2012;

					voteChangeByTract[ctVoteData.key] = +change;
				}
			});

			var nonWhitePerByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].PERCNONWHITE_2015;
				if (value == "error" || value == "null") {
					nonWhitePerByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				nonWhitePerByTract[ctDemoChangeD.key] = value;
				}
			});

			var nonWhiteChangeByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].PERCNONWHITE_CHANGE;
				if (value == "error" || value == "null") {
					nonWhiteChangeByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				nonWhiteChangeByTract[ctDemoChangeD.key] = value;
				}
			});

			var unempPerByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].UNEMPLOYMENT_2015;
				if (value == "error" || value == "null") {
					unempPerByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				unempPerByTract[ctDemoChangeD.key] = value;
				}
			});

			var unempChangeByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].UNEMPLOYMENT_CHANGE;
				if (value == "error" || value == "null") {
					unempChangeByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				unempChangeByTract[ctDemoChangeD.key] = value;
				}
			});

			var collegePerByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].COLLEGE_2015;
				if (value == "error" || value == "null") {
					collegePerByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				collegePerByTract[ctDemoChangeD.key] = value;
				}
			});

			var collegeChangeByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].COLLEGE_CHANGE;
				if (value == "error" || value == "null") {
					collegeChangeByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				collegeChangeByTract[ctDemoChangeD.key] = value;
				}
			});

			var incomePerByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].MEDIANINC_2015;
				if (value == "error" || value == "null") {
					incomePerByTract[ctDemoChange.key] = "ERROR";
				}
				else {
				incomePerByTract[ctDemoChangeD.key] = value;
				}
			});

			var incomeChangeByTract = {};
			ctDemoChangeD.forEach(function(ctDemoChange) {
				var value = +ctDemoChange.values[0].MEDIANINC_CHANGE;
				if (value == "error" || value == "null") {
					incomeChangeByTract[ctDemoChangeD.key] = "ERROR";
				}
				else {
				incomeChangeByTract[ctDemoChangeD.key] = value;
				}
			});

			// var dCTVotesHolder = {};
			// ctVoteData.forEach(function(ctVoteData) {
			// 	dCTVotesHolder[ctVoteData.key] = +ctVoteData.values[0].DEM_USC;
			// 	});
				
			// var rCTVotesHolder = {};
			// ctVoteData.forEach(function(ctVoteData) {
			// 	rCTVotesHolder[ctVoteData.key] = +ctVoteData.values[0].REP_USC;
			// });

			// var oCTVotesHolder = {};
			// ctVoteData.forEach(function(ctVoteData) {
			// 	oCTVotesHolder[ctVoteData.key] = +ctVoteData.values[0].OTHERS_USC;
			// });

			// var dSum = d3.sum(ctVoteData, function(d) {return d.values[0].DEM_USC;});
			// var rSum = d3.sum(ctVoteData, function(d) {return d.values[0].REP_USC;});
			// var oSum = d3.sum(ctVoteData, function(d) {return d.values[0].OTHERS_USC;});
			// var paSum = (dSum + rSum + oSum);
			

			
			//
			//
			//Create color scales (to hold selector map and PA vote grid)
			/////////////////////////////////////////////
			var voteColor = d3.scaleThreshold()
		        .domain([-0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1.0])
		        .range(['#3c5bff','#5c79ff','#7c98ff','#9cb7ff','#bcd6ff','#ffd5d4','#f8aab4','#f17f94','#ea5574','#dd0035']);

		    var voteChangeColor = d3.scaleThreshold()
		        .domain([-0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1.0])
		        .range(['#3c5bff','#5c79ff','#7c98ff','#9cb7ff','#bcd6ff','#ffd5d4','#f8aab4','#f17f94','#ea5574','#dd0035']);

			//
			//
			//Create top container (to hold selector map and PA vote grid)
			/////////////////////////////////////////////
				var viz1BoxWidth = 900,
					viz1BoxHeight = 300;

				var viz1Container = d3.select("#viz1").append("svg")
					.attr("class", "container")
					.attr("width", viz1BoxWidth)
					.attr("height", viz1BoxHeight);

			//
			//
			//Create small map of Pennsylvania in topSelection
			/////////////////////////////////////////////
				var mapBoxWidth = 500,
					mapBoxHeight = 300,
					mapBoxMarginLeft = 50;

				//Create container to hold map graphic
				var mapSmContainer = viz1Container.append("svg")
					.attr("width", mapBoxWidth)
					.attr("height", mapBoxHeight)
					.attr("x", mapBoxMarginLeft);

				d3.queue()
          			.defer(d3.json, "jsons/PA_CongDist_2015.json")
			        .defer(d3.json, "jsons/PA_CensusTractsbyCD_2010.json")
			        .await(makeSelectorMap);
				

				function makeSelectorMap(error, cdMap, ctMap) {
					if (error) return console.error(error);
				  
					var projection = d3.geoAlbers()
				    .scale(6000)
				    .rotate( [77.1945,0] )
		    		.center( [0, 41.2033] )
				    .translate([mapBoxWidth / 2, mapBoxHeight / 2]);

				    var path = d3.geoPath()
				    .projection(projection);

				    var clickTimes = 0;
				    
				    //
				    //make map for CDs
				    //set visibility to "visible" (until click)
					mapSmContainer.append("g")
						.selectAll("path")
				    .data(topojson.feature(cdMap, cdMap.objects.PA_CongDist_2015).features) 
				      	.enter().append("path")
				      	.attr("class", "cd-boundaries selector-map")
				      	.attr("d", path)
				      	.attr("CD", function(d) {return +d.properties.CD114FP})
				      	.attr("cdWinner", function(d) {
				      		var cd = this.getAttribute("CD");
				      		console.log("cd");
				      		var dVotes = +dCDVotesHolder[cd];
				      		var rVotes = +rCDVotesHolder[cd];
				      		var oVotes = +oCDVotesHolder[cd];
				      		if ((dVotes > rVotes) && (dVotes > oVotes)) {
				      			return "DEM";
				      		}
				      		if ((rVotes > dVotes) && (rVotes > oVotes)) {
				      			return "REP";
				      		}
				      		if ((oVotes > dVotes) && (oVotes > rVotes)) {
				      			return "OTH";
				      		}
				      	})
				      	.style("fill", initialColor)
				      	.style("visibility", "visible")
				      	.on("mouseover", handleMapMouseOver)
				      	.on("mouseout", handleMapMouseOut)
				      	.on("click", handleMapClick)
				      	.transition()
				      		.delay(function(d) {
				      			var cdNum = d.properties.CD114FP;
				      			return (300+(cdNum*70));
				      		})
				      		.duration(420)   	
					     	.style("fill", function(d) {
				      			if (this.getAttribute("cdWinner") == "DEM") {
				      				return dMapColor;
				      			}
				      			if (this.getAttribute("cdWinner") == "REP") {
				      				return rColor;
				      			}
				      			if (this.getAttribute("cdWinner") == "REP") {
				      				return oColor;
								}
				      		});

					function handleMapClick(d) {

						var cdSel = this.getAttribute("CD")
						// var cdSel = function() {return this.getAttribute("CD");}
						console.log(cdSel);

						console.log(clickTimes);

						

						var demoVizBoxWidth = 900,
							demoVizBoxHeight = 300;

						if (clickTimes == 0) { 
							var demoVizContainer = d3.select("#perCDDemos").append("svg")
								.attr("class", "container")
								.attr("width", demoVizBoxWidth)
								.attr("height", demoVizBoxHeight);

						}

						else {
							d3.select("#perCDDemos").selectAll(".container").remove();

							var demoVizContainer = d3.select("#perCDDemos").append("svg")
								.attr("class", "container")
								.attr("width", demoVizBoxWidth)
								.attr("height", demoVizBoxHeight);

						}

						var changeVizBoxWidth = 900,
							changeVizBoxHeight = 300;

						if (clickTimes == 0) { 
							var changeVizContainer = d3.select("#perCDChange").append("svg")
								.attr("class", "container")
								.attr("width", changeVizBoxWidth)
								.attr("height", changeVizBoxHeight);

						}

						else {
							d3.select("#perCDChange").selectAll(".container").remove();

							var changeVizContainer = d3.select("#perCDChange").append("svg")
								.attr("class", "container")
								.attr("width", demoVizBoxWidth)
								.attr("height", demoVizBoxHeight);

						}
						
						makeDemoElements();
						

						makeCDChangeElement();

						//
						//FUNCTIONS within handleMouseClick
						/////////////////////////////////////////
						clickTimes += 1;


						function makeDemoElements() {

							var mapBoxWidth = 500,
								mapBoxHeight = 300,
								mapBoxMarginLeft = 0;
					

							//Create containers to hold map graphics
							var demoMapContainer = demoVizContainer.append("svg")
								.attr("class", "container")
								.attr("width", mapBoxWidth)
								.attr("height", mapBoxHeight)
								.attr("x", mapBoxMarginLeft);

							var changeMapContainer = changeVizContainer.append("svg")
								.attr("class", "container")
								.attr("width", mapBoxWidth)
								.attr("height", mapBoxHeight)
								.attr("x", mapBoxMarginLeft);
						
							//
							//Make small CD maps
							var projection = d3.geoAlbers()
								.rotate( [77.1945,0] );

							var path = d3.geoPath()
							    .projection(projection);
							
							var jsonName = "jsons/CD" + cdSel + "_CT.json";

							d3.json(jsonName, function(error, ctMap) {
						  		if (error) return console.error(error);

							  	var tracts = topojson.feature(ctMap, ctMap.objects.CD).features
							  	var allTracts = topojson.feature(ctMap, ctMap.objects.CD);

							  	projection
							  		.scale(1)
							  		.translate([0,0]);

							  	var b = path.bounds(allTracts),
								    s = .95 / Math.max((b[1][0] - b[0][0]) / mapBoxWidth, (b[1][1] - b[0][1]) / mapBoxHeight),
								    t = [(mapBoxWidth - s * (b[1][0] + b[0][0])) / 2, (mapBoxHeight - s * (b[1][1] + b[0][1])) / 2];

								projection
							    	.scale(s)
							    	.translate(t);

							    //someone style the shit out of me please!!! :)
							   	demoMapContainer.append("g")
							   		.selectAll("path")
							   		.data(tracts)
							   		.attr("class", "demo-ct-boundaries")
							   		.enter().append("path")
							   		.attr("d", path)
							   		.style("stroke", "black")
							    	.attr("fill", function(d) { 
							      		var name = d.properties.GEO_ID,
									      	margin = voteMarginByTract[name];
									    if (margin == "ERROR") {
									    	return initialColor;
									    }
									    else { return voteColor(voteMarginByTract[name]);}
							      		});

							    changeMapContainer.append("g")
							   		.selectAll("path")
							   		.data(tracts)
							   		.enter().append("path")
							   		.attr("d", path)
							   		.style("stroke", "black")
							    	.attr("fill", function(d) { 
							      		var name = d.properties.GEO_ID,
									      	change = voteChangeByTract[name];
									      	
									    if (change == "ERROR") {
									    	return initialColor;
									    }
									    else { return voteChangeColor(voteChangeByTract[name]);}
							      		});
							//end d3.json call ->
						    });

								//Create bars container for CD bars
								var barsBoxWidth = 300,
									barsBoxHeight = 180,
									barsPadding = 53;

								//Create container to hold map graphic
								var barsBoxContainer = demoVizContainer.append("svg")
									.attr("width", barsBoxWidth)
									.attr("height", barsBoxHeight)
									.attr("x", mapBoxWidth+mapBoxMarginLeft+barsPadding)
									.attr("y", demoVizBoxHeight-barsBoxHeight);


								//Set dimensions of bar elements
								var h_bar = 180,
									w_bar = 25;
									barSq = 5;

								var barRows = h_bar/barSq,
									barCols = w_bar/barSq,
									numBarSquares = barRows*barCols;

								var dVotes = +dCDVotesHolder[cdSel],
									rVotes = +rCDVotesHolder[cdSel],
									oVotes = +oCDVotesHolder[cdSel],	
									cdTotalVotes = (dVotes+rVotes+oVotes),
									perD = (dVotes/cdTotalVotes),
									perR = (rVotes/cdTotalVotes),
									perO = (oVotes/cdTotalVotes),
									cutD = perD*barRows*barCols,
									cutOther = ((dVotes+oVotes)/cdTotalVotes)*barRows*barCols;


								//Make votes bar

								var voteBar = barsBoxContainer.append("svg")
									.attr("width", w_bar)
									.attr("height", h_bar)
									.attr("x", 0)
									.attr("y", 0);

								voteBar.append("rect")
								    .attr("class", "cd-drag-bar")
								    .style("pointer-events", "all")
								    .attr("width", w_bar)
								    .attr("height", h_bar)
								    .style("fill", "none")
								    // .on("click", handleBarMouseClick);

								var delayTime = 8,
									delayTimeOther = delayTime*2
									pauseTime = 500;
								
								var squares = voteBar.selectAll("cd-bar-square")
									.data(d3.range(numBarSquares))
							  	  .enter()
									.append('rect')
									.attr("class", "cd-bar-square")
									// .attr("CD", CD.key)
									.attr("width", barSq)
									.attr("height", barSq)
									.attr("cellnum", function (i) {return ((numBarSquares)-i);})
									.attr("x", function(i) {return (barSq*(i%barCols));})
									.attr("y", function(i) {return (barSq*Math.floor((i/barCols)));})
									.style("fill",initialColor)
									.style("stroke", "ffffff")
									.style("stroke-width", .4)      
					    			.style("stroke-linecap", "butt")
							    	.style("pointer-events", "none")
							    	.attr("squareColor", function(){
										if (this.getAttribute('cellnum') <= cutD) {
											console.log("heloooo!");
										    return dColor;
										}
										if (this.getAttribute('cellnum') > cutD && (this.getAttribute('cellnum') <= cutOther)) {
											return oColor;
										}
										else {return rColor;}
									})
									.transition()
								     	.delay(function() {
											if (this.getAttribute('squareColor') == dColor) {
							   					return (pauseTime+this.getAttribute("cellnum")*delayTime);
							     			}
							     			if (this.getAttribute('squareColor') == oColor) {
							   					return (pauseTime+((this.getAttribute("cellnum")*delayTimeOther)+(cutOther*delayTime)));
							     			}
							     			if (this.getAttribute('squareColor') == rColor) {
							     	
							     				return (pauseTime+((cutD*delayTime)+((numBarSquares)-this.getAttribute("cellnum")+1)*delayTime));
							     				}
											})     	
								     	.style("fill", function() {
												return this.getAttribute('squareColor')
										});

									
									var	numBars = cdDemoD.length,
										barMargin = {top: 0, right: 16, bottom: 0, left: 16},
										boxMargin = {top: 30, right: 30, bottom: 0, left: 0};


									var svg = barsBoxContainer.selectAll("svg")
										.data(cdDemoD)
									  .enter()
										.append("svg") //svg container for one bar element
										.attr("width", w_bar+barMargin.left+barMargin.right)
										.attr("height", h_bar+barMargin.top+barMargin.bottom)
										.attr("x", function (d, i) {
											return (boxMargin.left-barMargin.left+(i*(w_bar+barMargin.right+barMargin.left)));
										})
									  .append("g") //g for bar itself, placed in svg container
								    	.attr("transform", "translate(" + barMargin.left + "," + barMargin.top + ")");

									var svgbar = svg.append("g")
										.attr("width", w_bar)
										.attr("height", h_bar)
										.each(makeBars);


									function makeBars(VAR) {
										var svg = d3.select(this)
											.attr("class", "bar")
											// .attr("var", VAR.key)
											.style("fill", "none");	
								
										//make transparent rectangle to pick up click
										svg.append("rect")
										    .attr("class", "drag-bar")
										    // .attr("CD", CD.key)
										    .style("pointer-events", "all")
										    .attr("width", w_bar)
										    .attr("height", h_bar)
										    .style("fill", "none");
										    .on("click", handleBarClick);

								    	
										//makes squares as "rect" elements
										var squares = svg.selectAll(".bar-square")
											.data(d3.range(numBarSquares))
									  	  .enter()
											.append('rect')
											.attr("class", "bar-square")
											.attr("VAR", VAR.key)
											.attr("width", barSq)
											.attr("height", barSq)
											.attr("cellnum", function (i) {return ((numBarSquares)-i);})
											.attr("x", function(i) {return (barSq*(i%barCols));})
											.attr("y", function(i) {return (barSq*Math.floor((i/barCols)));})
											.style("fill",initialColor)
											.style("stroke", "ffffff")
											.style("stroke-width", .4)      
							    			.style("stroke-linecap", "butt")
							    			.style("pointer-events", "none")
							    			.attr("squareColor", getSquareColor);
							    			 

							    // 			 {
											// 	if (this.getAttribute('cellnum') <= cutD) {
											// 	    return dColor;
											// 	}
											// 	if (this.getAttribute('cellnum') > cutD && (this.getAttribute('cellnum') <= cutOther)) {
											// 		return oColor;
											// 	}
											// 	else {return rColor;}
											// };


										function getSquareColor () {

											cat = this.getAttribute("VAR");

											cat_value = +cdDemoD[cat][cdSel];
											// var max = d3.max(cdDemo, function(d) { return +d.field_goal_attempts;} );

										}

										function handleBarClick () {

											d3.selectAll(".demo-ct-boundaries")
										    	.attr("fill", function(d) { 
										      		var name = d.properties.GEO_ID,
												      	margin = voteMarginByTract[name];
												    if (margin == "ERROR") {
												    	return initialColor;
												    }
												    else { return voteColor(voteMarginByTract[name]);}
										      		});



										}
												// .attr("squareColor", function() {
												// 	if (this.getAttribute('cellnum') <= cutD) {
												// 	    return dColor;
												// 	}
												// 	if (this.getAttribute('cellnum') > cutD && (	this.getAttribute('cellnum') <= cutOther)) {
												// 		return oColor;
												// 	}
												// 	else {return rColor;}
												// })
												// .transition()
											 //     	.delay(function() {
												// 		if (this.getAttribute('squareColor') == dColor) {
										  //  					return (pauseTime+this.getAttribute("cellnum")*delayTime);
										  //    			}
										  //    			if (this.getAttribute('squareColor') == oColor) {
										  //  					return (pauseTime+((this.getAttribute("cellnum")*delayTimeOther)+(cutOther*delayTime)));
										  //    			}
										  //    			if (this.getAttribute('squareColor') == rColor) {
										     	
										  //    				return (pauseTime+((cutD*delayTime)+((numBarSquares)-this.getAttribute("cellnum")+1)*delayTime));
										  //    				}
												// 		})     	
											 //     	.style("fill", function() {
												// 			return this.getAttribute('squareColor')
												// 		});
								     
								     

							// }

						//end makeDemoMap function ->
						}


						//end handleMouseClick function ->
						}







				//end makeSelectorMap function ->
			}
					     
					//
					//make map for CTs
					//set visibility to "hidden" (until click)
				  //   mapSmContainer.append("g")
						// .selectAll("path")
				  //   .data(topojson.feature(ctMap, ctMap.objects.PA_AllCTsbyCD).features) 
				  //     	.enter().append("path")
				  //     	.attr("class", "ct-boundaries selector-map")
				  //     	.attr("d", path)
				  //     	.attr("CD", function(d) {return +d.properties.CD114FP})
				  //     	.attr("CT", function(d) {return d.properties.GEO_ID})
				  //     	.attr("ctWinner", function(d, ctData) {
				  //     		var ct = this.getAttribute("CT");
				  //     		// console.log(ct);
				  //     		var dVotes = +dCTVotesHolder[ct];
				  //     		// var dVotes = +cdData[cd].values[0].DEM_USC;
				  //     		var rVotes = +rCTVotesHolder[ct];
				  //     		var oVotes = +oCTVotesHolder[ct];
				  //     		// console.log(rVotes);
				  //     		if ((dVotes > rVotes) && (dVotes > oVotes)) {
				  //     			return "DEM";
				  //     		}
				  //     		if ((rVotes > dVotes) && (rVotes > oVotes)) {
				  //     			return "REP";
				  //     		}
				  //     		if ((oVotes > dVotes) && (oVotes > rVotes)) {
				  //     			return "OTH";
				  //     		}
				  //     	})
				  //     	// .on("mouseover", handleMapMouseOver)
				  //     	// .on("mouseout", handleMapMouseOut)
				  //     	// .on("click", handleMapClick)
				  //     	.style("fill", initialColor)
				  //     	.style("visibility", "hidden")
				  //     	// .transition()
				  //     	// 	// .delay(function(d) {
				  //     	// 	// 	var cdNum = +d.properties.CD114FP;
				  //     	// 	// 	return (300+(cdNum*70));
				  //     	// 	// })
				  //     	// 	.duration(420)   	
				  //    	.style("fill", function(d) {
						// 	var ctNum = d.properties.GEO_ID;
			   //    			if (this.getAttribute("ctWinner") == "DEM") {
			   //    				return dMapColor;
			   //    			}
			   //    			if (this.getAttribute("ctWinner") == "REP") {
			   //    				return rColor;
			   //    			}
			   //    			if (this.getAttribute("ctWinner") == "REP") {
			   //    				return oColor;
						// 	}
			   //    		})
			   //    		.style("stroke-width", "0");				      		
				
				


			//
			//
			//Create vote grid for Pennsylvania at large in top container
			/////////////////////////////////////////////
				var voteGridWidth = 200,
					voteGridHeight = 200,
					gridSq = 5,
					gridRows = voteGridHeight/gridSq,
					gridCols = voteGridWidth/gridSq,
					numGridSquares = gridRows*gridCols;

				//Create container to hold vote grid graphic
				var voteGridContainer = viz1Container.append("svg")
					.attr("width", voteGridWidth)
					.attr("height", voteGridHeight)
					.attr("x", 580)
					.attr("y", 80)
					.append("g");
						
				var grid = voteGridContainer.each(makeVoteGrid);

			//end of vote grid


			






			

			function makeCDChangeElement() {


			}

			function handleMapMouseOver(d) {

				//select cd boundary of mouseover and class as "active-mouseover"
				// d3.selectAll(".cd-boundaries").filter(function(){return this.getAttribute("CD") == CD.key})
				d3.select(this)
					.classed("active-mouseover", true)
					.raise();

				//display data?

			}

			function handleMapMouseOut() {

				//unclass selection (i.e. mouseover element) as "active-mouseover"
				d3.select(this)
					.classed("active-mouseover", false);
					

			}

			
		

			

			// function updateSelectorMap() {

			// 	d3.queue
			// 		.delay("data/CD_VoteData.tsv")
			// 		.delay()

			// 	d3.tsv("data/CD_Data_all.tsv", function(data) {

			// 		//nest data by CD	
			// 		var cdData = d3.nest()
			// 			.key(function(d) {return d.CD;}) 
			// 			.entries(data);

			// 		console.log(cdData);

			// 		d3.json("jsons/PA_CensusTracts_2010.json", function(error, pa) {
			// 			if (error) return console.error(error);

			// 			d3.select(mapSmContainer).selectAll("g")
			// 				.remove();

			// 			var projection = d3.geoAlbers()
			// 		    .scale(5000)
			// 		    .rotate( [77.1945,0] )
			//     		.center( [0, 41.2033] )
			// 		    .translate([mapBoxWidth / 2, mapBoxHeight / 2]);

			// 		    var path = d3.geoPath()
			// 		    .projection(projection);


			// 			mapSmContainer.append("g")
			// 				.selectAll("path")
			// 		    .data(topojson.feature(pa, pa.objects.PA_CensusTracts_2015).features) 
			// 		      	.enter().append("path")
			// 		      	.attr("class", "cd-boundaries")
			// 		      	.attr("d", path)
			// 		      	.attr("CD", function(d) {return +d.properties.CD114FP})
			// 		      	.attr("CT", function(d) {return +d.propertoes.GEO_ID})
			// 		      	.attr("ctWinner", function(d, cdData) {
			// 		      		var cd = this.getAttribute("CD");
			// 		      		var dVotes = +dVotesHolder[cd];
			// 		      		// var dVotes = +cdData[cd].values[0].DEM_USC;
			// 		      		var rVotes = +rVotesHolder[cd];
			// 		      		var oVotes = +oVotesHolder[cd];
			// 		      		if ((dVotes > rVotes) && (dVotes > oVotes)) {
			// 		      			return "DEM";
			// 		      		}
			// 		      		if ((rVotes > dVotes) && (rVotes > oVotes)) {
			// 		      			return "REP";
			// 		      		}
			// 		      		if ((oVotes > dVotes) && (oVotes > rVotes)) {
			// 		      			return "OTH";
			// 		      		}
			// 		      	})
			// 		      	.on("mouseover", handleMapMouseOver)
			// 		      	.on("mouseout", handleMapMouseOut)
			// 		      	.on("click", handleMapClick)
			// 		      	.style("fill", initialColor)
			// 		      	.transition()
			// 		      		.delay(function(d) {
			// 		      			var cdNum = +d.properties.CD114FP;
			// 		      			return (300+(cdNum*70));
			// 		      		})
			// 		      		.duration(420)   	
			// 			     	.style("fill", function(d) {
			// 						var cdNum = +d.properties.CD114FP;
			// 		      			if (this.getAttribute("ctWinner") == "DEM") {
			// 		      				return dMapColor;
			// 		      			}
			// 		      			if (this.getAttribute("ctWinner") == "REP") {
			// 		      				return rColor;
			// 		      			}
			// 		      			if (this.getAttribute("ctWinner") == "REP") {
			// 		      				return oColor;
			// 						}
			// 		      		});


			// 		}	  
			// 	}
			// }


			function makeVoteGrid() {

				//var svg = voteGridContainer.append("svg");
				var svg = d3.select(this);
 
				var	perDGrid = (dSum/paSum),
					perRGrid = (rSum/paSum),
					perOGrid = (oSum/paSum),
					cutDGrid = perDGrid*gridRows*gridCols,
					cutOtherGrid = ((dSum+oSum)/paSum)*gridRows*gridCols;


				var delayTime = 2.8,
					pauseTime = 0;

				//makes squares as "rect" elements
				var gridSquares = svg.selectAll(".grid-square")
					.data(d3.range(numGridSquares))
			  	  .enter()
					.append('rect')
					.attr("class", "grid-square")
					.attr("width", gridSq)
					.attr("height", gridSq)
					.attr("cellnum", function (i) {return ((numGridSquares)-i);})
					.attr("x", function(i) {return (gridSq*(i%gridCols));})
					.attr("y", function(i) {return (gridSq*Math.floor((i/gridCols)));})
					.style("fill",initialColor)
					.style("stroke", "ffffff")
					.style("stroke-width", .4)      
	    			.style("stroke-linecap", "butt")		
					.attr("squareColor", function() {
						if (this.getAttribute('cellnum') <= cutDGrid) {
						    return dColor;
						}
						if (this.getAttribute('cellnum') > cutDGrid && (this.getAttribute('cellnum') <= cutOtherGrid)) {
							return oColor;
						}
						else if (this.getAttribute('cellnum') > cutOtherGrid) {return rColor;}
					})
					.transition()
				     	.delay(function() {
							if (this.getAttribute('squareColor') == dColor) {
			   					return (pauseTime+this.getAttribute("cellnum")*delayTime);
			     			}
			     			if (this.getAttribute('squareColor') == oColor) {
			     				if (cutOtherGrid < (numGridSquares)/2) {
			   						return (pauseTime+(((numGridSquares)-(this.getAttribute("cellnum"))+1)*delayTime)+(100*delayTime));
			     				}
			     				else {
			   						return (pauseTime+((this.getAttribute("cellnum"))+1)*delayTime)+(100*delayTime);
			     				}
			     			}
			     			if (this.getAttribute('squareColor') == rColor) {
			     				return (pauseTime+((numGridSquares)-this.getAttribute("cellnum")+1)*delayTime);
			     				}
							})     	
				     	.style("fill", function() {
								return this.getAttribute('squareColor')
							});
			//end makeVoteGrid function ->
			}

			function updateVoteGrid() {

			}


			function makeCDStatsMap() {






			}


			function makeCDStatsBars() {

			}


			function makeCDChangeMap() {



			}


			function makeCDChangeBars() {
				
			}
		}
	}
		
</script>
</body>
</html>